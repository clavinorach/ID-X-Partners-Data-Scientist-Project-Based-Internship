# -*- coding: utf-8 -*-
"""Final Task ID/X Partners Data Scientist Project Based Internship - Clavino Ourizqi Rachmadi

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D-yVuaA7BO5tUTIMVfaBE4q4KVlbEBBh

# **Credit Risk Model Project-Based Virtual Intern: ID/X Partners Data Scientist x Rakamin Academy**

<div align=center>
  <img src="https://algorit.ma/wp-content/uploads/2021/03/Logo-IDX-Partners.jpg"/>
</div>

Author: [Clavino Ourizqi Rachmadi](https://www.linkedin.com/in/clavinorachmadi/)

Github: [@clavinorach](https://github.com/clavinorach)

# **Latar Belakang**

Sebagai Data Scientist di ID/X Partners, saya diberi kesempatan untuk terlibat dalam proyek sebuah perusahaan multifinance yang bergerak di pemberian pinjaman. Dalam proyek ini, klien ingin meningkatkan akurasi dalam menilai dan mengelola risiko kredit, sehingga mereka dapat membuat keputusan bisnis yang lebih tepat dan mengurangi potensi kerugian. Tugas saya adalah mengembangkan model machine learning yang dapat memprediksi risiko kredit berdasarkan dataset yang mencakup data pinjaman yang disetujui maupun yang ditolak. Proyek ini mencakup beberapa tahapan penting, mulai dari pemahaman data (Data Understanding), eksplorasi dan analisis data (Exploratory Data Analysis), persiapan data (Data Preparation), pemodelan (Data Modelling), hingga evaluasi performa model (Evaluation).

# **Informasi Dataset**
<p align=justify>
Dataset ini memiliki 75 fitur atau kolom yang menawarkan wawasan potensial untuk model machine learning dapat memprediksi risiko penggunaan (This dataset has 75 features or columns that offer potential insights for machine learning models to predict the risk of use).
</p>

**Berikut merupakan penjelasan setiap fitur yang ada (The following is an explanation of each feature)**:

- ```acceptD```: Tanggal dimana peminjam menerima penawaran (The date which the borrower accepted the offer).
- ```accNowDelinq```: Jumlah akun yang saat ini ditunggak oleh peminjam (The number of accounts on which the borrower is now delinquent).
- ```accOpenPast24Mths```: Jumlah transaksi (trade) yang dibuka dalam 24 bulan terakhir (Number of trades opened in past 24 months).
- ```addrState```: Negara bagian yang diberikan oleh peminjam dalam aplikasi pinjaman (The state provided by the borrower in the loan application).
- ```all_util```: Rasio saldo terhadap limit kredit pada semua transaksi (Balance to credit limit on all trades).
- ```annual_inc_joint```: Total pendapatan tahunan gabungan yang dilaporkan oleh peminjam bersama co-borrower saat registrasi (The combined self-reported annual income provided by the co-borrowers during registration).
- ```annualInc```: Pendapatan tahunan yang dilaporkan oleh peminjam saat registrasi (The self-reported annual income provided by the borrower during registration).
- ```application_type```: Menunjukkan apakah aplikasi pinjaman diajukan secara individu atau bersama (Indicates whether the loan is an individual application or a joint application with two co-borrowers).
- ```avg_cur_bal```: Rata-rata saldo berjalan dari semua akun (Average current balance of all accounts).
- ```bcOpenToBuy```: Total limit kredit yang tersedia untuk pembelian pada kartu kredit (Total open to buy on revolving bankcards).
- ```bcUtil```: Rasio saldo berjalan total terhadap limit kredit pada semua akun kartu kredit (Ratio of total current balance to high credit/credit limit for all bankcard accounts).
- ```chargeoff_within_12_mths```: Jumlah charge-offs (penghapusan piutang macet) dalam 12 bulan (Number of charge-offs within 12 months).
- ```collections_12_mths_ex_med```: Jumlah koleksi (penagihan) dalam 12 bulan, tidak termasuk koleksi medis (Number of collections in 12 months excluding medical collections).
- ```creditPullD```: Tanggal dimana LC melakukan pengecekan kredit untuk pinjaman ini (The date LC pulled credit for this loan).
- ```delinq2Yrs```: Jumlah insiden keterlambatan pembayaran >30 hari dalam 2 tahun terakhir pada laporan kredit peminjam (The number of 30+ days past-due incidences of delinquency in the borrower's credit file for the past 2 years).
- ```delinqAmnt```: Jumlah tunggakan pada akun-akun yang saat ini ditunggak (The past-due amount owed for the accounts on which the borrower is now delinquent).
- ```desc```: Deskripsi pinjaman yang diberikan oleh peminjam (Loan description provided by the borrower).
- ```dti```: Rasio yang dihitung dengan membagi total pembayaran utang bulanan peminjam (tidak termasuk hipotek dan pinjaman LC) dengan pendapatan bulanan yang dilaporkan (A ratio calculated using the borrower’s total monthly debt payments on the total debt obligations, excluding mortgage and the requested LC loan, divided by the borrower’s self-reported monthly income).
- ```dti_joint```: Rasio yang dihitung menggunakan total pembayaran utang bulanan co-borrower (tidak termasuk hipotek dan pinjaman LC) dibagi dengan pendapatan bulanan gabungan yang dilaporkan (A ratio calculated using the co-borrowers' total monthly payments on the total debt obligations, excluding mortgages and the requested LC loan, divided by the co-borrowers' combined self-reported monthly income).
- ```earliestCrLine```: Tanggal pembukaan jalur kredit pertama yang dilaporkan oleh peminjam (The date the borrower's earliest reported credit line was opened).
- ```effective_int_rate```: Suku bunga efektif yang merupakan suku bunga pinjaman dikurangi estimasi LC atas dampak bunga yang belum tertagih sebelum charge off (The effective interest rate is equal to the interest rate on a Note reduced by Lending Club's estimate of the impact of uncollected interest prior to charge off).
- ```emp_title```: Jabatan pekerjaan yang diberikan oleh peminjam saat mengajukan pinjaman (The job title supplied by the Borrower when applying for the loan).
- ```empLength```: Lama masa kerja peminjam dalam tahun (Nilai antara 0-10, dimana 0 berarti kurang dari satu tahun dan 10 berarti sepuluh tahun atau lebih) (Employment length in years. Possible values are between 0 and 10 where 0 means less than one year and 10 means ten or more years).
- ```expD```: Tanggal kedaluwarsa listing pinjaman (The date the listing will expire).
- ```expDefaultRate```: Perkiraan tingkat default (gagal bayar) pinjaman (The expected default rate of the loan).
- ```ficoRangeHigh```: Batas atas rentang skor FICO peminjam saat origination pinjaman (The upper boundary range the borrower’s FICO at loan origination belongs to).
- ```ficoRangeLow```: Batas bawah rentang skor FICO peminjam saat origination pinjaman (The lower boundary range the borrower’s FICO at loan origination belongs to).
- ```fundedAmnt```: Total jumlah dana yang dikomitmenkan untuk pinjaman tersebut pada saat itu (The total amount committed to that loan at that point in time).
- ```grade```: Grade pinjaman yang ditetapkan oleh LC (LC assigned loan grade).
- ```homeOwnership```: Status kepemilikan tempat tinggal yang dilaporkan peminjam saat registrasi (Nilai: RENT, OWN, MORTGAGE, OTHER) (The home ownership status provided by the borrower during registration).
- ```id```: ID LC unik yang ditetapkan untuk daftar pinjaman (A unique LC assigned ID for the loan listing).
- ```il_util```: Rasio saldo berjalan total terhadap limit kredit pada semua akun angsuran (installment accounts) (Ratio of total current balance to high credit/credit limit on all installment accounts).
- ```ils_exp_d```: Tanggal kedaluwarsa platform wholeloan (wholeloan platform expiration date).
- ```initialListStatus```: Status awal listing pinjaman (Nilai: W, F) (The initial listing status of the loan. Possible values are – W, F).
- ```inq_fi```: Jumlah pertanyaan (inquiries) terkait keuangan personal (Number of personal finance inquiries).
- ```inq_last_12m```: Jumlah pertanyaan kredit dalam 12 bulan terakhir (Number of credit inquiries in past 12 months).
- ```inqLast6Mths```: Jumlah pertanyaan kredit dalam 6 bulan terakhir (tidak termasuk pertanyaan untuk auto dan hipotek) (The number of inquiries in past 6 months excluding auto and mortgage inquiries).
- ```installment```: Pembayaran bulanan yang harus dibayar peminjam jika pinjaman disetujui (The monthly payment owed by the borrower if the loan originates).
- ```intRate```: Suku bunga pinjaman (Interest Rate on the loan).
- ```isIncV```: Menunjukkan apakah pendapatan telah diverifikasi oleh LC, tidak diverifikasi, atau sumber pendapatan diverifikasi (Indicates if income was verified by LC, not verified, or if the income source was verified).
- ```listD```: Tanggal aplikasi pinjaman peminjam dipublikasikan di platform (The date which the borrower's application was listed on the platform).
- ```loanAmnt```: Jumlah pinjaman yang diajukan oleh peminjam (jika kemudian dikurangi oleh departemen kredit, akan tercermin pada nilai ini) (The listed amount of the loan applied for by the borrower).
- ```max_bal_bc```: Saldo maksimum yang terhutang pada semua akun kartu kredit (Maximum current balance owed on all revolving accounts).
- ```memberId```: ID anggota LC unik untuk peminjam (A unique LC assigned Id for the borrower member).
- ```mo_sin_old_rev_tl_op```: Jumlah bulan sejak pembukaan akun revolving tertua (Months since oldest revolving account opened).
- ```mo_sin_rcnt_rev_tl_op```: Jumlah bulan sejak akun revolving yang paling baru dibuka (Months since most recent revolving account opened).
- ```mo_sin_rcnt_tl```: Jumlah bulan sejak akun (trade) yang paling baru dibuka (Months since most recent account opened).
- ```mortAcc```: Jumlah akun hipotek (Number of mortgage accounts).
- ```msa```: Wilayah Statistik Metropolitan peminjam (Metropolitan Statistical Area of the borrower).
- ```mths_since_last_major_derog```: Jumlah bulan sejak rating 90 hari atau lebih buruk terakhir (Months since most recent 90-day or worse rating).
- ```mths_since_oldest_il_open```: Jumlah bulan sejak akun angsuran (installment) tertua dibuka (Months since oldest bank installment account opened).
- ```mths_since_rcnt_il```: Jumlah bulan sejak akun angsuran (installment) terbaru dibuka (Months since most recent installment accounts opened).
- ```mthsSinceLastDelinq```: Jumlah bulan sejak keterlambatan pembayaran terakhir peminjam (The number of months since the borrower's last delinquency).
- ```mthsSinceLastRecord```: Jumlah bulan sejak catatan publik terakhir (The number of months since the last public record).
- ```mthsSinceMostRecentInq```: Jumlah bulan sejak pertanyaan kredit terbaru (Months since most recent inquiry).
- ```mthsSinceRecentBc```: Jumlah bulan sejak akun kartu kredit terbaru dibuka (Months since most recent bankcard account opened).
- ```mthsSinceRecentLoanDelinq```: Jumlah bulan sejak keterlambatan pinjaman personal terbaru (Months since most recent personal finance delinquency).
- ```mthsSinceRecentRevolDelinq```: Jumlah bulan sejak keterlambatan revolving terbaru (Months since most recent revolving delinquency).
- ```num_accts_ever_120_pd```: Jumlah akun yang pernah terlambat 120 hari atau lebih (Number of accounts ever 120 or more days past due).
- ```num_actv_bc_tl```: Jumlah akun kartu kredit aktif saat ini (Number of currently active bankcard accounts).
- ```num_actv_rev_tl```: Jumlah transaksi revolving aktif saat ini (Number of currently active revolving trades).
- ```num_bc_sats```: Jumlah akun kartu kredit dengan status memuaskan (Number of satisfactory bankcard accounts).
- ```num_bc_tl```: Jumlah akun kartu kredit (Number of bankcard accounts).
- ```num_il_tl```: Jumlah akun angsuran (installment accounts) (Number of installment accounts).
- ```num_op_rev_tl```: Jumlah akun revolving yang terbuka (Number of open revolving accounts).
- ```num_rev_accts```: Jumlah akun revolving (Number of revolving accounts).
- ```num_rev_tl_bal_gt_0```: Jumlah transaksi revolving yang memiliki saldo lebih dari 0 (Number of revolving trades with balance >0).
- ```num_sats```: Jumlah akun dengan status memuaskan (Number of satisfactory accounts).
- ```num_tl_120dpd_2m```: Jumlah akun yang saat ini terlambat 120 hari (diperbarui dalam 2 bulan terakhir) (Number of accounts currently 120 days past due, updated in past 2 months).
- ```num_tl_30dpd```: Jumlah akun yang saat ini terlambat 30 hari (diperbarui dalam 2 bulan terakhir) (Number of accounts currently 30 days past due, updated in past 2 months).
- ```num_tl_90g_dpd_24m```: Jumlah akun yang terlambat 90 hari atau lebih dalam 24 bulan terakhir (Number of accounts 90 or more days past due in last 24 months).
- ```num_tl_op_past_12m```: Jumlah akun yang dibuka dalam 12 bulan terakhir (Number of accounts opened in past 12 months).
- ```open_acc_6m```: Jumlah transaksi (trade) terbuka dalam 6 bulan terakhir (Number of open trades in last 6 months).
- ```open_il_12m```: Jumlah akun angsuran yang dibuka dalam 12 bulan terakhir (Number of installment accounts opened in past 12 months).
- ```open_il_24m```: Jumlah akun angsuran yang dibuka dalam 24 bulan terakhir (Number of installment accounts opened in past 24 months).
- ```open_il_6m```: Jumlah transaksi angsuran aktif saat ini (Number of currently active installment trades).
- ```open_rv_12m```: Jumlah transaksi revolving yang dibuka dalam 12 bulan terakhir (Number of revolving trades opened in past 12 months).
- ```open_rv_24m```: Jumlah transaksi revolving yang dibuka dalam 24 bulan terakhir (Number of revolving trades opened in past 24 months).
- ```openAcc```: Jumlah jalur kredit terbuka dalam laporan kredit peminjam (The number of open credit lines in the borrower's credit file).
- ```pct_tl_nvr_dlq```: Persentase transaksi yang tidak pernah mengalami keterlambatan (Percent of trades never delinquent).
- ```percentBcGt75```: Persentase akun kartu kredit yang menggunakan lebih dari 75% limit (Percentage of all bankcard accounts > 75% of limit).
- ```pub_rec_bankruptcies```: Jumlah kebangkrutan yang tercatat dalam catatan publik (Number of public record bankruptcies).
- ```pubRec```: Jumlah catatan publik negatif (derogatory public records) (Number of derogatory public records).
- ```purpose```: Kategori pinjaman yang diajukan oleh peminjam (A category provided by the borrower for the loan request).
- ```reviewStatus```: Status pinjaman selama periode listing (Nilai: APPROVED, NOT_APPROVED) (The status of the loan during the listing period).
- ```reviewStatusD```: Tanggal saat aplikasi pinjaman direview oleh LC (The date the loan application was reviewed by LC).
- ```revolBal```: Total saldo kredit revolving (Total credit revolving balance).
- ```revolUtil```: Rasio pemanfaatan jalur kredit revolving (jumlah kredit yang digunakan dibandingkan dengan kredit yang tersedia) (Revolving line utilization rate, or the amount of credit the borrower is using relative to all available revolving credit).
- ```serviceFeeRate```: Tarif biaya layanan yang dibayar investor untuk pinjaman ini (Service fee rate paid by the investor for this loan).
- ```subGrade```: Subgrade pinjaman yang ditetapkan oleh LC (LC assigned loan subgrade).
- ```tax_liens```: Jumlah beban pajak yang menempel (Number of tax liens).
- ```term```: Jumlah pembayaran pinjaman (dalam bulan, biasanya 36 atau 60) (The number of payments on the loan. Values are in months and can be either 36 or 60).
- ```title```: Judul pinjaman yang diberikan oleh peminjam (The loan title provided by the borrower).
- ```tot_coll_amt```: Total jumlah yang pernah tertagih dari koleksi (Total collection amounts ever owed).
- ```tot_cur_bal```: Total saldo berjalan dari semua akun (Total current balance of all accounts).
- ```tot_hi_cred_lim```: Total limit kredit atau high credit (Total high credit/credit limit).
- ```total_bal_il```: Total saldo berjalan dari semua akun angsuran (Total current balance of all installment accounts).
- ```total_cu_t```: Jumlah transaksi finansial (Number of finance trades).
- ```total_il_high_credit_limit```: Total limit kredit pada akun angsuran (Total installment high credit/credit limit).
- ```total_rev_hi_lim```: Total limit kredit pada akun revolving (Total revolving high credit/credit limit).
- ```totalAcc```: Total jumlah jalur kredit dalam laporan kredit peminjam (The total number of credit lines currently in the borrower's credit file).
- ```totalBalExMort```: Total saldo kredit, tidak termasuk hipotek (Total credit balance excluding mortgage).
- ```totalBcLimit```: Total limit kredit pada akun kartu kredit (Total bankcard high credit/credit limit).
- ```url```: URL halaman LC untuk data listing pinjaman (URL for the LC page with listing data).
- ```verified_status_joint```: Menunjukkan apakah pendapatan bersama co-borrower telah diverifikasi oleh LC, tidak diverifikasi, atau sumber pendapatan diverifikasi (Indicates if the co-borrowers' joint income was verified by LC, not verified, or if the income source was verified).
- ```zip_code```: Tiga digit pertama kode pos yang diberikan oleh peminjam pada aplikasi pinjaman (The first 3 numbers of the zip code provided by the borrower in the loan application).

**Disclaimer**:
<p align=justify>
Dataset ini hanya mencantumkan 75 fitur. Perlu diketahui bahwa kemungkinan besar fitur-fitur lain telah diseleksi atau dikurangi dari dataset asli untuk tujuan penyederhanaan, peningkatan kinerja analisis, serta untuk memenuhi standar privasi dan kepatuhan. Pastikan untuk mengacu pada dokumentasi resmi dataset untuk informasi lengkap mengenai proses seleksi dan transformasi fitur yang dilakukan.
</p>

Source: <a href="https://docs.google.com/spreadsheets/d/1iT1JNOBwU4l616_rnJpo0iny7blZvNBs/edit?gid=1001272030#gid=1001272030">LCDataDictionary</a>

# Tahapan Analisa Data

Dalam proyek ini, terdapat beberapa tahapan kunci yang dilakukan untuk membangun model prediksi risiko kredit secara efektif. Berikut adalah penjabaran masing-masing tahap:

1. **Business Understanding**  
   Tahap ini melibatkan pemahaman mendalam tentang tujuan bisnis dan tantangan yang dihadapi oleh perusahaan multifinance. Di sini, fokusnya adalah:
   - Mengidentifikasi masalah utama, yaitu penilaian risiko kredit.
   - Menentukan dampak kegagalan peminjam terhadap profitabilitas dan stabilitas bisnis.
   - Merumuskan tujuan proyek, misalnya meningkatkan akurasi penilaian risiko untuk mengoptimalkan keputusan pinjaman.

2. **Analytical Approach**  
   Di tahap ini, pendekatan analitis yang tepat dipilih untuk mengatasi masalah yang ada. Hal ini meliputi:
   - Pemilihan metode machine learning yang akan digunakan, seperti Logistic Regression, Random Forest, dan XGBoost.
   - Perumusan hipotesis dan strategi evaluasi model untuk mengukur performa prediksi.
   - Penentuan metrik evaluasi yang akan digunakan (akurasi, presisi, recall, F1-score, ROC AUC, dsb.).

3. **Data Storytelling**  
   Tahap ini berfokus pada komunikasi insight dari data dengan cara yang mudah dipahami oleh stakeholder. Aktivitas yang dilakukan antara lain:
   - Membangun narasi yang menghubungkan hasil analisis dengan tujuan bisnis.
   - Menyusun laporan dan presentasi visual yang menjelaskan temuan utama dan rekomendasi.
   - Menekankan bagaimana model prediksi risiko dapat mendukung pengambilan keputusan.

4. **Exploratory Data Analysis (EDA)**  
   Di tahap EDA, data dieksplorasi secara mendalam untuk memahami karakteristik dan pola yang terdapat di dalamnya. Kegiatan utama meliputi:
   - Analisis statistik deskriptif untuk melihat sebaran dan distribusi data.
   - Identifikasi nilai hilang, outlier, dan anomali.
   - Eksplorasi hubungan antar variabel yang dapat mempengaruhi risiko kredit.

5. **Data Visualization**  
   Visualisasi data sangat penting untuk membantu memahami insight dari EDA dan menyampaikan cerita data. Pada tahap ini dilakukan:
   - Pembuatan grafik histogram, boxplot, scatter plot, heatmap, dan ROC curve.
   - Visualisasi hubungan antar variabel dan tren dari waktu ke waktu.
   - Penyajian data secara visual agar mudah dipahami oleh pihak bisnis.

6. **Machine Learning**  
   Tahap akhir melibatkan penerapan algoritma machine learning untuk membangun model prediksi. Langkah-langkah yang dilakukan meliputi:
   - Pembagian data menjadi set pelatihan dan pengujian (train/test split).
   - Penerapan teknik penyeimbangan kelas (misalnya, SMOTE) untuk mengatasi masalah class imbalance.
   - Pelatihan beberapa model (Logistic Regression, Random Forest, XGBoost) dan evaluasi performa mereka menggunakan metrik yang telah ditentukan.
   - Analisis hasil evaluasi untuk memilih model yang paling optimal dalam mengidentifikasi risiko kredit.

Setiap tahapan di atas saling terkait dan mendukung proses pembangunan model yang andal untuk menilai risiko kredit, sehingga keputusan bisnis dapat dioptimalkan dan potensi kerugian diminimalkan.

#Data Understanding
**Tujuan:** Memahami struktur dan karakteristik dasar dataset.

**A.  Import Libraries & Dataset**
"""

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive')

#Membaca dataset
df = pd.read_csv('/content/drive/MyDrive/Project Based Intern ID X Partners/loan_data_2007_2014.csv')

df.head()

#Meliiat dimensi pada dataset
df.shape

"""**B. Identifikasi Struktur Dataset**"""

#Identifikasi struktur dataset
df.info()

"""**C.  Handling Missing Values**"""

# Melihat persentase nilai yang hilang atau missing value yang ada
# pada variabel baru missing_values

missing_values = df.isnull().sum()/df.shape[0]
missing_values

# Misal: DataFrame 'df' sudah terdefinisi dan merupakan dataset asli
# Menghitung proporsi missing value untuk setiap kolom dan menyimpannya ke dalam DataFrame 'missing_values'
missing_values = pd.DataFrame(df.isnull().mean(), columns=['missing_proportion'])

# Memilih nilai-nilai dalam kolom pertama dari DataFrame missing_values (yaitu, 'missing_proportion')
# dan membuat kondisi untuk memilih baris di mana proporsi missing value lebih dari 50%
high_missing = missing_values[missing_values.iloc[:, 0] > 0.50]

# Menampilkan DataFrame baru yang hanya berisi kolom-kolom dengan >50% missing value
print(high_missing)

# Misal: DataFrame 'df' sudah ada dan kita sudah menghitung proporsi missing value per kolom
missing_values = pd.DataFrame(df.isnull().mean(), columns=['missing_proportion'])

# Mengurutkan DataFrame berdasarkan kolom pertama ('missing_proportion') secara descending
missing_values_sorted = missing_values.sort_values(by=missing_values.columns[0], ascending=False)

print(missing_values_sorted)

# Hapus kolom yang memiliki data kosong lebih dari 50%
# data.shape[0] memberikan jumlah baris, sehingga data.dropna(thresh= data.shape[0]*0.5, axis=1)
# hanya mempertahankan kolom yang memiliki setidaknya 50% data non-null.
df.dropna(thresh=df.shape[0] * 0.5, axis=1, inplace=True)

# Hitung proporsi missing value untuk setiap kolom yang tersisa
missing_values = pd.DataFrame(df.isnull().sum() / df.shape[0], columns=['missing_proportion'])

# Pilih hanya kolom-kolom dengan missing value > 50%
# missing_values.iloc[:, 0] mengambil kolom pertama (yaitu, 'missing_proportion')
high_missing = missing_values[missing_values.iloc[:, 0] > 0.50]

# Mengurutkan kolom-kolom tersebut berdasarkan proporsi missing value secara menurun
high_missing_sorted = high_missing.sort_values(by=high_missing.columns[0], ascending=False)

print(high_missing_sorted)

"""sekarang data dengan missing values diatas 50% sudah tidak ada"""

df = df.drop(columns=['url'])

# Pemeriksaan duplikat
print("\nJumlah Duplikat:", df.duplicated().sum())
df.drop_duplicates(inplace=True)

# Statistik deskriptif untuk fitur numerik
print(df.describe())

# Statistik untuk fitur kategorikal
print(df.describe(include=['object']))

# Informasi tipe data dan jumlah nilai non-null
print(df.info())

# Mengidentifikasi nilai unik pada kolom 'loan_status'
unique_status = df['loan_status'].unique()
print("Nilai unik pada 'loan_status':", unique_status)
# Fungsi unique() mengembalikan array nilai unik yang terdapat pada kolom tersebut.

# 2. Membuat kolom baru 'loan_performance'
# Kolom ini berisi nilai 1 jika 'loan_status' menunjukkan pembayaran tidak tepat waktu,
# yaitu jika nilainya termasuk di antara ['Charged Off', 'Default', 'Late (31-120 days)', 'Late (16-30 days)'],
# dan 0 jika pembayaran tepat waktu.
df['loan_performance'] = np.where(
    df['loan_status'].isin(['Charged Off', 'Default', 'Late (31-120 days)', 'Late (16-30 days)']),
    1,
    0
)

# Menampilkan jumlah masing-masing kategori pada kolom 'loan_performance'
performance_counts = df['loan_performance'].value_counts()
print("Distribusi loan_performance (0: tepat waktu, 1: tidak tepat waktu):")
print(performance_counts)

# Scatter plot antara 'annual_inc' dan 'loan_amnt'
plt.figure(figsize=(8, 6))
sns.scatterplot(x='annual_inc', y='loan_amnt', data=df)
plt.title('Scatter Plot: Annual Income vs Loan Amount')
plt.show()

"""#Exploratory Data Analysis (EDA)
**Tujuan:** Memahami data secara mendalam, mengidentifikasi pola dan hubungan, serta mendeteksi anomali

**A.  Descriptive Statistics**
"""

df.info()

df.describe()

"""Karena data terlalu banyak, data akan dibersihan untuk mendapatkan fitur yang paling penting."""

# List nama kolom yang ingin dihapus
columns_to_drop = ["grade",
                "sub_grade",
                  "home_ownership",
                  "verification_status",
                  "purpose",]

# Hapus kolom dari dataset
df = df.drop(columns=columns_to_drop)

# Cek hasil
df.info()

# Cek apakah masih ada pinjaman yang memiliki pembayaran berikutnya
print(df['next_pymnt_d'].notnull().sum())

# Statistik berdasarkan loan_performance
print(df.groupby('loan_performance')['next_pymnt_d'].describe())

"""Berdasarkan analisis, diketahui bahwa terdapat 239.071 kreditur yang akan membayar pada pembayaran berikutnya (next_pymnt_d)."""

# Statistik dasar terhadap kolom 'last_pymnt_d'
print("Statistik dasar untuk 'last_pymnt_d':")
print(df['last_pymnt_d'].describe())

# Distribusi 'last_pymnt_d' berdasarkan kategori 'loan_performance'
print("\nDistribusi 'last_pymnt_d' berdasarkan 'loan_performance':")
print(df.groupby('loan_performance')['last_pymnt_d'].describe())

# Statistik dasar terhadap kolom 'last_credit_pull_d'
print("\nStatistik dasar untuk 'last_credit_pull_d':")
print(df['last_credit_pull_d'].describe())

# Distribusi 'last_credit_pull_d' berdasarkan kategori 'loan_performance'
print("\nDistribusi 'last_credit_pull_d' berdasarkan 'loan_performance':")
print(df.groupby('loan_performance')['last_credit_pull_d'].describe())

"""**B.  Data Cleaning**"""

df.shape

# Looping untuk menampilkan kolom bertipe 'object' dan 'bool' beserta nilai uniknya
for col in df.select_dtypes(include=['object', 'bool']).columns:
    print(f"Kolom: {col}")
    print("Nilai unik:", df[col].unique())
    print()  # Baris kosong sebagai pemisah antar kolom

# Daftar kolom yang perlu dibersihkan (ordinal)
col_need_to_clean = ['term', 'emp_length', 'issue_d', 'earliest_cr_line', 'last_pymnt_d', 'next_pymnt_d', 'last_credit_pull_d']

# Tampilkan nilai unik pada kolom 'term' sebelum pembersihan
print("Nilai unik 'term' sebelum pembersihan:", df['term'].unique())

# Pembersihan kolom 'term'
# Menghapus string ' months' dan mengubah nilai menjadi numerik
df['term'] = pd.to_numeric(df['term'].str.replace(' months', '', regex=False))

# Tampilkan kembali nilai unik pada kolom 'term' setelah pembersihan
print("Nilai unik 'term' setelah pembersihan:", df['term'].unique())

# Pembersihan kolom 'emp_length'
print("Nilai unik 'emp_length' sebelum pembersihan:", df['emp_length'].unique())

# Menghapus string yang tidak diinginkan dan mengubah kolom 'emp_length' menjadi numerik
df['emp_length'] = df['emp_length'].str.replace('\+ years', '', regex=True)
df['emp_length'] = df['emp_length'].str.replace(' years', '', regex=True)
df['emp_length'] = df['emp_length'].str.replace('< 1 year', '0', regex=False)
df['emp_length'] = df['emp_length'].str.replace(' year', '', regex=False)

df['emp_length'].unique()

df['emp_length'] = pd.to_numeric(df['emp_length'])
df['emp_length']

df['emp_length'] = df['emp_length'].fillna(0.0)

# Berikut menghilangkan data 'NaN'dan merubah keseluruhan data menjadi integer
df['emp_length'] = df['emp_length'].astype(str)
df['emp_length'].unique()

# Kolom 'emp_length' akan dirubah kedalam bentuk numerik dan akan dihilangkan stringnya

df['emp_length'] = df['emp_length'].str.replace('\+ years', '')
df['emp_length'] = df['emp_length'].str.replace(' years', '')
df['emp_length'] = df['emp_length'].str.replace('< 1 year', '0')
df['emp_length'] = df['emp_length'].str.replace(' year', '')


df['emp_length'].fillna(value = 0, inplace=True)

# Daftar kolom bertipe tanggal
  col_date = ['issue_d', 'earliest_cr_line', 'last_pymnt_d', 'next_pymnt_d', 'last_credit_pull_d']

  # Menampilkan data untuk kolom-kolom yang bertipe date
  print("Data pada kolom-kolom tanggal:")
  print(df[col_date])

# Melihat apakah ada baris yang kosong di masing-masing kolom bertipe tanggal
print("\nJumlah missing values pada setiap kolom bertipe tanggal:")
for n in col_date:
    print(f"{n}: {df[n].isnull().sum()}")

# Menghapus baris yang memiliki NaN pada kolom bertipe tanggal
for m in col_date:
    df = df.dropna(subset=[m])
    print(f"{m} - Jumlah missing values setelah penghapusan: {df[m].isnull().sum()}")

# Menambahkan tahun '20' di depan angka tahun untuk mengubahnya menjadi 4 digit
for col in col_date:
    df[col] = df[col].apply(lambda x: x.replace(f"-{x[-2:]}", f"-20{x[-2:]}") if isinstance(x, str) else x)

# Mengubah kolom-kolom tanggal menjadi tipe 'datetime'
for col in col_date:
    df[col] = pd.to_datetime(df[col])

# Menampilkan kolom yang sudah berubah menjadi tipe datetime
print("\nData setelah konversi menjadi datetime:")
print(df[col_date])

"""**C.  Inference Statistics**
### Unvariate Analysis
Tujuan analisis univariat adalah untuk menggambarkan data, menemukan pola, dan meringkas kumpulan data menjadi informasi yang berguna.
"""

# Menentukan jumlah kolom yang akan dianalisis
num_cols = len(col_need_to_clean)

# Membuat subplots dengan grid horizontal
fig, axes = plt.subplots(nrows=1, ncols=num_cols, figsize=(num_cols * 4, 4))  # Set ukuran grid horizontal

# Jika hanya ada satu kolom yang dianalisis, memastikan axes menjadi array
if num_cols == 1:
    axes = [axes]

# Loop untuk setiap kolom pada 'col_need_to_clean'
for i, col in enumerate(col_need_to_clean):
    axes[i].hist(df[col].dropna(), bins=30, color='royalblue', alpha=0.7)  # Histogram data untuk kolom tersebut
    axes[i].set_title(f"Distribusi {col}", fontsize=12)  # Judul plot untuk kolom
    axes[i].tick_params(axis='x', rotation=45, labelsize=10)  # Rotasi label x-axis
    axes[i].set_ylabel("Jumlah Observasi", fontsize=10)  # Label untuk y-axis

# Layout yang rapat agar plot tidak tumpang tindih
plt.tight_layout()

# Menampilkan plot
plt.show()

"""**Insight yang Dapat Diambil:**

1.  **Distribusi Kolom 'term':**
Kolom 'term' menunjukkan dua kategori utama, yaitu 36 bulan dan 60 bulan. Hal ini terlihat pada histogram yang menunjukkan dua puncak yang sangat jelas, yang masing-masing mewakili dua durasi pinjaman yang umum dalam dataset. Meskipun ada beberapa variasi, mayoritas pinjaman dalam dataset ini tampaknya lebih banyak memiliki durasi 36 bulan, yang merupakan kategori yang lebih umum.

2.  **Distribusi Kolom 'emp_length':**
Pada histogram untuk 'emp_length' (lama pekerjaan), terdapat puncak yang jelas pada angka 10+ tahun, namun banyak juga yang memiliki durasi pekerjaan kurang dari 1 tahun. Ini menunjukkan bahwa banyak peminjam yang baru bekerja atau baru bergabung dengan pekerjaan mereka, sementara hanya sedikit yang memiliki pengalaman lebih dari 10 tahun.

3.  **Distribusi Kolom 'issue_d' (Tanggal Penerbitan Pinjaman):**
Histogram 'issue_d' menunjukkan bahwa sebagian besar pinjaman diterbitkan antara tahun 2010 dan 2016, dengan konsentrasi terbesar sekitar tahun 2013 hingga 2014. Ini bisa menjadi indikator bahwa periode tersebut adalah puncak dalam pengajuan pinjaman.

4.  **Distribusi Kolom 'earliest_cr_line' (Tanggal Awal Kredit):**
Untuk 'earliest_cr_line', data menunjukkan adanya konsentrasi besar pada tahun 2000-an, terutama pada awal tahun 2000 hingga sekitar 2010. Hal ini menunjukkan bahwa banyak peminjam dalam dataset ini mungkin memiliki riwayat kredit yang sudah ada sejak lama.

5.  **Distribusi Kolom 'last_pymnt_d' (Tanggal Pembayaran Terakhir):**
Pada 'last_pymnt_d', terlihat bahwa sebagian besar pembayaran terakhir dilakukan sekitar tahun 2016 hingga 2017, dengan konsentrasi yang jelas. Hal ini bisa menunjukkan bahwa pembayaran terakhir pinjaman terjadi dalam beberapa tahun terakhir.

6.  **Distribusi Kolom 'next_pymnt_d' (Tanggal Pembayaran Berikutnya):**
Seperti pada kolom pembayaran terakhir, distribusi 'next_pymnt_d' menunjukkan konsentrasi besar pada tahun 2016-2017. Hal ini menunjukkan bahwa sebagian besar peminjam kemungkinan besar dijadwalkan untuk melakukan pembayaran pinjaman dalam periode yang sama.

7.  **Distribusi Kolom 'last_credit_pull_d' (Tanggal Penarikan Laporan Kredit Terakhir):**
Seperti kolom lainnya yang berkaitan dengan tanggal, 'last_credit_pull_d' menunjukkan konsentrasi besar pada tahun 2015 hingga 2016. Hal ini mungkin menunjukkan bahwa perusahaan peminjam cenderung menarik laporan kredit pada periode tersebut.

---

**Observasi:**
- Data distribusi untuk beberapa kolom tanggal seperti 'last_pymnt_d', 'next_pymnt_d', dan 'last_credit_pull_d' menunjukkan bahwa sebagian besar transaksi atau aktivitas pinjaman terfokus pada beberapa tahun terakhir (2015-2017). Hal ini dapat berarti bahwa sebagian besar pinjaman adalah yang baru dan data historis menunjukkan adanya perubahan dalam tren pinjaman.
- Kolom-kolom terkait durasi pinjaman, seperti 'term', sangat terpusat pada dua nilai, yaitu 36 bulan dan 60 bulan. Ini bisa menjadi informasi penting untuk memahami jenis pinjaman yang paling banyak diajukan.
- Tanggal yang terkait dengan kegiatan peminjaman atau pembayaran menunjukkan pola yang cukup terpusat dalam waktu tertentu, yang menunjukkan bahwa sebagian besar transaksi terjadi dalam beberapa tahun terakhir.

**Analisa Lanjutan**

> **Tujuan:** Melihat tren penerbitan pinjaman berdasarkan tahun
"""

# Plot distribusi jumlah pinjaman per tahun
plt.figure(figsize=(10, 5))

# Menghitung jumlah pinjaman per tahun dari kolom 'issue_d' yang sudah bertipe datetime
df['issue_d'].dt.year.value_counts().sort_index().plot(kind='bar', color='royalblue')

# Menambahkan label dan judul
plt.xlabel("Tahun Penerbitan Pinjaman", fontsize=12)
plt.ylabel("Jumlah Pinjaman", fontsize=12)
plt.title("Distribusi Penerbitan Pinjaman per Tahun", fontsize=14)

# Menampilkan plot
plt.show()

"""

> Pembandingan tingkat gagal bayar peminjam dengan riwayat kredit

"""

# Hitung usia kredit dalam tahun
df['credit_age'] = (df['issue_d'] - df['earliest_cr_line']).dt.days / 365

# Visualisasi: Boxplot usia kredit berdasarkan status pinjaman (loan_performance)
plt.figure(figsize=(12, 6))
sns.boxplot(x='loan_performance', y='credit_age', data=df, showfliers=False, palette="coolwarm")
plt.xlabel("Status Pinjaman", fontsize=12)
plt.ylabel("Usia Kredit (Tahun)", fontsize=12)
plt.title("Usia Kredit vs Status Pinjaman", fontsize=14)
plt.xticks(rotation=45)
plt.show()

"""Karena tidak ada perbedaan signifikan, maka usia kredit mungkin bukan faktor utama dalam menentukan risiko gagal bayar. Akan lebih lanjut dengan statistical test (ANOVA) untuk melihat apakah perbedaannya signifikan.

**Hipotesis:**

* H₀ (Hipotesis Nol):
Tidak ada perbedaan yang signifikan dalam usia kredit antara kelompok peminjam yang gagal bayar dan yang membayar tepat waktu. Artinya, usia kredit tidak mempengaruhi apakah seseorang gagal bayar atau tidak.

* H₁ (Hipotesis Alternatif):
Ada setidaknya satu kelompok (gagal bayar atau membayar tepat waktu) yang memiliki rata-rata usia kredit yang berbeda secara signifikan. Ini berarti usia kredit dapat mempengaruhi kemungkinan gagal bayar.
"""

import scipy.stats as stats

# 1. Melakukan Uji ANOVA untuk perbandingan usia kredit ('credit_age') berdasarkan status pinjaman ('loan_performance')
# Grup 0 adalah yang bayar tepat waktu (good), dan grup 1 adalah yang gagal bayar (bad)

good_credit_age = df[df['loan_performance'] == 0]['credit_age']
bad_credit_age = df[df['loan_performance'] == 1]['credit_age']

# Uji ANOVA
f_stat, p_value = stats.f_oneway(good_credit_age, bad_credit_age)

# 2. Menampilkan hasil Uji ANOVA
print(f"F-statistic: {f_stat}")
print(f"P-value: {p_value}")

# 3. Interpretasi hasil uji ANOVA
if p_value < 0.05:
    print("Terdapat perbedaan signifikan antara usia kredit peminjam yang gagal bayar dan yang tidak.")
else:
    print("Tidak ada perbedaan signifikan antara usia kredit peminjam yang gagal bayar dan yang tidak.")

# Membagi data berdasarkan status pinjaman (loan_performance)
good_credit_age = df[df['loan_performance'] == 0]['credit_age']  # Peminjam yang bayar tepat waktu
bad_credit_age = df[df['loan_performance'] == 1]['credit_age']   # Peminjam yang gagal bayar

# 1. Uji ANOVA
f_stat, p_value = stats.f_oneway(good_credit_age, bad_credit_age)

# 2. Tampilkan hasil uji ANOVA
print(f"F-statistic: {f_stat:.4f}")
print(f"P-value: {p_value:.4f}")

# 3. Interpretasi hasil
alpha = 0.05
if p_value < alpha:
    print("Hasil: Tolak H₀. Ada perbedaan signifikan dalam usia kredit berdasarkan status pinjaman.")
else:
    print("Hasil: Gagal menolak H₀. Tidak ada perbedaan signifikan dalam usia kredit berdasarkan status pinjaman.")

# 4. Membuat subplots untuk visualisasi
fig, axes = plt.subplots(2, 1, figsize=(8, 12))  # 2 baris, 1 kolom, ukuran grafik lebih besar

# 5. Visualisasi dengan boxplot
sns.boxplot(x='loan_performance', y='credit_age', data=df, ax=axes[0])  # Boxplot pada subplot pertama
axes[0].set_xlabel("Status Pinjaman")
axes[0].set_ylabel("Usia Kredit")
axes[0].set_title("Boxplot Usia Kredit berdasarkan Status Pinjaman")

# 6. Visualisasi distribusi data dengan histogram
sns.histplot(df, x='credit_age', hue='loan_performance', element='step', stat='density',
             common_norm=False, kde=True, ax=axes[1])  # Histogram pada subplot kedua
axes[1].set_xlabel("Usia Kredit")
axes[1].set_ylabel("Kepadatan")
axes[1].set_title("Distribusi Usia Kredit berdasarkan Status Pinjaman")

# Menyusun layout untuk menghindari overlap antar subplots
plt.tight_layout()

# Menampilkan plot
plt.show()

"""
> Analisis keterlambatan pembayaran dengan membandingkan last_pymnt_d dengan issue_d

"""

# Hitung selisih bulan antara last_pymnt_d dan issue_d
df['payment_delay_months'] = (df['last_pymnt_d'].dt.year - df['issue_d'].dt.year) * 12 + \
                               (df['last_pymnt_d'].dt.month - df['issue_d'].dt.month)

# Plot distribusi keterlambatan pembayaran
plt.figure(figsize=(10, 5))
plt.hist(df['payment_delay_months'].dropna(), bins=30, color='darkorange', edgecolor='black')  # Drop NaN values
plt.xlabel("Lama Pembayaran (Bulan)", fontsize=12)
plt.ylabel("Jumlah Peminjam", fontsize=12)
plt.title("Distribusi Keterlambatan Pembayaran", fontsize=14)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()# Hitung selisih bulan antara last_pymnt_d dan issue_d
df['payment_delay_months'] = (df['last_pymnt_d'].dt.year - df['issue_d'].dt.year) * 12 + \
                               (df['last_pymnt_d'].dt.month - df['issue_d'].dt.month)

"""

> Pengecekan apakah ada peminjam yang seharusnya memiliki jadwal pembayaran tetapi tidak ada data next_pymnt_d sebagai indikasi kredit macet."""

# Plot distribusi next payment date
plt.figure(figsize=(10, 5))
df['next_pymnt_d'].dt.year.value_counts().sort_index().plot(kind='bar', color='purple')
plt.xlabel("Tahun Pembayaran Berikutnya", fontsize=12)
plt.ylabel("Jumlah Peminjam", fontsize=12)
plt.title("Distribusi Next Payment Date", fontsize=14)
plt.xticks(rotation=45)
plt.show()

# Cek apakah ada peminjam yang seharusnya memiliki jadwal pembayaran tetapi tidak memiliki next_pymnt_d
missing_next_pymnt = df[df['next_pymnt_d'].isna()]
print(f"Jumlah peminjam tanpa jadwal pembayaran berikutnya: {len(missing_next_pymnt)}")

"""

> Distribusi data target `loan_performance`



"""

# Barplot
sns.countplot(x="loan_performance", data=df)
plt.title("Distribution of Loan Status")
plt.show()

"""Dapat dilihat bahwa variabel target mengalami ketidakseimbangan kelas (class imbalance), di mana jumlah data untuk satu kelas (misalnya, peminjam yang gagal bayar) jauh lebih sedikit dibandingkan dengan kelas lainnya (misalnya, peminjam yang membayar tepat waktu).

Ketidakseimbangan kelas ini menjadi masalah dalam model pembelajaran mesin (machine learning) karena model cenderung lebih memprediksi kelas mayoritas, sehingga kelas minoritas (dalam hal ini, peminjam yang gagal bayar) terabaikan. Akibatnya, meskipun model menunjukkan akurasi tinggi, performa model dalam memprediksi kelas minoritas bisa sangat buruk, yang akan memengaruhi efektivitas model dalam mengambil keputusan terkait risiko.

Untuk mengatasi masalah ini, salah satu teknik yang dapat digunakan adalah SMOTE (Synthetic Minority Over-sampling Technique). SMOTE adalah metode yang menghasilkan sampel sintetik untuk kelas minoritas dengan cara memanipulasi data yang ada, bukan hanya menambah data yang sudah ada. Dengan menambahkan contoh baru dari kelas minoritas, SMOTE bertujuan untuk menyeimbangkan jumlah contoh antara kedua kelas, sehingga model dapat belajar lebih baik untuk memprediksi kelas minoritas.

Dengan menerapkan SMOTE, kita dapat mengurangi efek ketidakseimbangan kelas dan meningkatkan kemampuan model dalam memprediksi kelas minoritas dengan lebih akurat, yang pada gilirannya akan meningkatkan performa model dalam aplikasi klasifikasi.

> ## Multivariate Analysis
Analisis multivariat adalah metode statistik yang menganalisis lebih dari satu variabel secara bersamaan. Analisis ini dapat digunakan untuk menjelaskan, mengukur, dan memprediksi hubungan antara variabel-variabel tersebut.
"""

plt.figure(figsize=(10,6))
sns.heatmap(df[col_need_to_clean].corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Korelasi Antar Variabel Waktu dan Status Kredit")
plt.show()

"""Analisa Lanjutan

> **Payment Date**
"""

# Plot scatter
plt.figure(figsize=(10, 6))
plt.scatter(df['last_pymnt_d'], df['next_pymnt_d'], alpha=0.5)

# Label dan judul
plt.xlabel('Last Payment Date')
plt.ylabel('Next Payment Date')
plt.title('Scatter Plot of Payment Dates')
plt.xticks(rotation=45)
plt.show()

"""> **Issues and payments correlation**


"""

# Pastikan kolom tanggal sudah dalam format datetime (gunakan errors='coerce' untuk menangani nilai yang tidak valid)
df['issue_d'] = pd.to_datetime(df['issue_d'], errors='coerce')
df['last_pymnt_d'] = pd.to_datetime(df['last_pymnt_d'], errors='coerce')
df['next_pymnt_d'] = pd.to_datetime(df['next_pymnt_d'], errors='coerce')

# Buat figure dengan ukuran yang diinginkan
plt.figure(figsize=(10, 6))

# Plot scatter untuk Tanggal Pembayaran Terakhir
plt.scatter(df['issue_d'], df['last_pymnt_d'],
            label='Tanggal Pembayaran Terakhir',
            alpha=0.6, marker='o')

# Plot scatter untuk Tanggal Pembayaran Berikutnya
plt.scatter(df['issue_d'], df['next_pymnt_d'],
            label='Tanggal Pembayaran Berikutnya',
            alpha=0.6, marker='x')

# Atur label, judul, dan grid
plt.xlabel('Tanggal Penerbitan Pinjaman', fontsize=12)
plt.ylabel('Tanggal Pembayaran', fontsize=12)
plt.title('Hubungan antara Tanggal Penerbitan dengan Tanggal Pembayaran', fontsize=14)
plt.legend()
plt.grid(True)

# Tampilkan plot
plt.show()

"""
> **Distribution of Term**

"""

plt.figure(figsize=(10, 6))
plt.hist(df['term'], bins=len(df['term'].unique()), alpha=0.7, edgecolor='black')

plt.xlabel('Term (Jangka Waktu Pinjaman)')
plt.ylabel('Frekuensi')
plt.title('Distribusi Term Pinjaman')

plt.show()

# Seleksi kolom numerik (mengabaikan kolom object dan datetime)
numeric_cols = df.select_dtypes(exclude=['object', 'datetime64']).columns

# Tentukan jumlah kolom dalam grid plot
ncols = 4
nrows = -(-len(numeric_cols) // ncols)  # Perhitungan pembulatan ke atas

# Buat subplots dengan ukuran figure yang sesuai
fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(20, 15))
axes = axes.flatten()

# Loop melalui setiap kolom numerik dan buat histogram
for i, col in enumerate(numeric_cols):
    df[col].hist(bins=30, ax=axes[i])
    axes[i].set_title(col, fontsize=12)

# Hapus axes kosong (jika ada)
for j in range(len(numeric_cols), len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""Berdasarkan histogram yang ada, kolom yang memiliki distribusi mendekati normal terletak pada kolom int_rate dan dti

**Menampilkan Outlier yang ada pada tiap kolom numerik**
"""

plt.figure(figsize=(23, 20))
num_rows = (len(numeric_cols) // 4) + 1  # Hitung jumlah baris secara dinamis
for i, col in enumerate(numeric_cols):
    plt.subplot(num_rows, 4, i + 1)
    sns.boxplot(y=df[col])
    plt.title(col, fontsize=12)
plt.tight_layout()
plt.show()

"""# Data Preparation
Pemrosesan fitur-fitur yang akan digunakan dalam modelling dilakukan agar data yang digunakan dapat memberikan model yang optimal.

**A.  Feature Engineering**
"""

# Seleksi fitur yang relevan untuk prediksi
df = df[['term', 'emp_length', 'issue_d', 'earliest_cr_line', 'last_pymnt_d', 'last_credit_pull_d', 'loan_performance']]

# Tampilkan 5 baris teratas untuk memastikan pemilihan fitur sudah benar
df.head()

# Catatan:
# Data inilah yang akan digunakan untuk prediksi karena fitur-fitur lainnya tidak relevan
# setelah tahap pembersihan (cleansing) data.

from datetime import date
import pandas as pd

# Mendapatkan tanggal hari ini dalam format datetime
today = pd.to_datetime(date.today().strftime('%Y-%m-%d'))

# Tanggal awal data dikumpulkan
start_date = pd.to_datetime('2007-06-01')

# Menghitung selisih hari antara hari ini dan tanggal awal
days_diff = today - start_date

# Menampilkan hasil dalam jumlah hari
print("Jumlah hari dari 2007-06-01 sampai hari ini:", days_diff.days)

# Dibentuk function untuk mengukur banyak bulan setelah peminjam meminjam uang
# Catatan : mengapa jumlah bulannya terlampau banyak dari kolom 'term', itu dikarenakan memakai acuan tanggal hari ini.
# Sehingga, data nya menjadi bias. Seharusnya, menggunakan acuan tanggal saat dimana pinjaman dibuat
# Namun, sebagai contoh tidak apa-apa

def date_columns(df, column):
    # Tanggal hari ini
    today_date = pd.to_datetime('2017-12-01')

    # Ubah kolom menjadi format datetime, tangani kesalahan dengan 'coerce' untuk nilai invalid
    df[column] = pd.to_datetime(df[column], format="%b-%y", errors='coerce')

    # Periksa dan tangani NaT (Not a Time) dengan menggantinya menjadi tanggal default (misalnya today_date)
    df[column].fillna(today_date, inplace=True)

    # Hitung jumlah bulan sejak tanggal tersebut
    df['mths_since_' + column] = (
        (today_date.year - df[column].dt.year) * 12 + (today_date.month - df[column].dt.month)
    )

    # Pastikan tidak ada nilai negatif
    df['mths_since_' + column] = df['mths_since_' + column].clip(lower=0)

    # Hapus kolom asli
    df.drop(columns=[column], inplace=True)



# Aplikasikan pada X_train
date_columns(df, 'earliest_cr_line')
date_columns(df, 'issue_d')
date_columns(df, 'last_pymnt_d')
date_columns(df, 'last_credit_pull_d')

df['mths_since_earliest_cr_line']

# Hitung median dari kolom 'mths_since_earliest_cr_line' (tanpa menghitung nilai 0)
median_value = df.loc[df['mths_since_earliest_cr_line'] > 0, 'mths_since_earliest_cr_line'].median()

# Ganti nilai 0 dengan median menggunakan .loc
df.loc[df['mths_since_earliest_cr_line'] == 0, 'mths_since_earliest_cr_line'] = median_value

# Tampilkan DataFrame
df

"""Pemrosesan ini digunakan untuk menghitung jumlah bulan sejak suatu tanggal tertentu hingga 1 Desember 2017 dalam dataset.

Setelah itu, jumlah bulan dihitung berdasarkan selisih antara tahun dan bulan dari tanggal tersebut dengan tanggal referensi, lalu nilai negatif dikoreksi menjadi nol.

**B.  Scalling Data**
"""

from sklearn.preprocessing import StandardScaler

# Daftar kolom yang akan dinormalisasi dengan Z-Score
cols_to_scale = ['term', 'emp_length', 'mths_since_earliest_cr_line',
                 'mths_since_issue_d', 'mths_since_last_pymnt_d', 'mths_since_last_credit_pull_d']

# Inisialisasi StandardScaler
scaler = StandardScaler()

# Terapkan fit_transform pada kolom yang dipilih dan simpan kembali ke DataFrame
df[cols_to_scale] = scaler.fit_transform(df[cols_to_scale])

# Normalisasi dilakukan dengan menggunakan Z-Score

df

"""Standarisasi dengan Z-score mengubah data sehingga memiliki rata-rata (mean) 0 dan standar deviasi 1. Dengan kata lain, setiap fitur diubah ke dalam skala yang sama, sehingga fitur-fitur dengan rentang nilai besar tidak mendominasi model. Teknik ini sangat penting bagi algoritma yang sensitif terhadap skala fitur—seperti regresi linier, KNN, SVM, dan PCA—karena memastikan bahwa semua fitur memberikan kontribusi yang seimbang dalam proses pelatihan dan prediksi. Dengan standarisasi Z-score, model dapat mempelajari pola dari setiap fitur secara adil, meningkatkan kinerja dan stabilitas hasil akhir.

**C.  Splitting data**
"""

from sklearn.model_selection import train_test_split
from imblearn.over_sampling import SMOTE
from collections import Counter

# Misalkan 'df' adalah DataFrame asli dan target adalah 'loan_performance'
# X: Semua fitur kecuali kolom 'loan_performance'
# y: Kolom 'loan_performance'
X = df.drop('loan_performance', axis=1)
y = df['loan_performance']

# Install library imbalanced-learn jika belum terpasang
!pip install imbalanced-learn

# Tampilkan distribusi kelas sebelum oversampling
print("Distribusi sebelum SMOTE:", Counter(y))

# Terapkan SMOTE untuk menghasilkan sampel sintetik bagi kelas minoritas
smote = SMOTE(sampling_strategy='auto', random_state=42)
X_resampled, y_resampled = smote.fit_resample(X, y)

# Tampilkan distribusi kelas setelah oversampling
print("Distribusi setelah SMOTE:", Counter(y_resampled))

# Bagi data hasil oversampling menjadi train set dan test set:
# - test_size=0.2: 20% data dialokasikan sebagai test set.
# - stratify=y_resampled: Memastikan distribusi kelas pada train dan test set sama seperti pada data resampled.
# - random_state=42: Memastikan reproducibility split data.
X_train, X_test, y_train, y_test = train_test_split(
    X_resampled, y_resampled, test_size=0.2, stratify=y_resampled, random_state=42
)

# Menampilkan distribusi nilai 'good' (0) dan 'bad' (1) pada train set dalam bentuk proporsi
  print("Distribusi pada Train Set:")
  print(y_train.value_counts(normalize=True))

# Menampilkan distribusi nilai 'good' (0) dan 'bad' (1) pada test set dalam bentuk proporsi
print("Distribusi pada Test Set:")
print(y_test.value_counts(normalize=True))

import matplotlib.pyplot as plt
import seaborn as sns

# Membuat barplot untuk mendistribusikan status pinjaman pada test set
plt.figure(figsize=(8, 6))
sns.countplot(x=y_test, palette='viridis')
plt.title("Distribution of Loan Status", fontsize=14)
plt.xlabel("Loan Status (0 = Good, 1 = Bad)", fontsize=12)
plt.ylabel("Count", fontsize=12)
plt.show()

y_test.shape

y_train.shape

X_test.shape

X_train.shape

"""# Data Modelling

**A.  Importing Models**
"""

# Import model machine learning yang akan digunakan

from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier

#Dibentuk variabel untuk model Logistic Regresi, yaitu 'model'

model = LogisticRegression()
model_2 = RandomForestClassifier()
model_3 = XGBClassifier()

# Inisialisasi model-model yang akan digunakan
model = LogisticRegression()
model_2 = RandomForestClassifier()
model_3 = XGBClassifier()

# Melatih setiap model dengan data train (X_train dan y_train)
model.fit(X_train, y_train)
model_2.fit(X_train, y_train)
model_3.fit(X_train, y_train)

# Melatih setiap model dengan data train (X_train dan y_train)
model.fit(X_train, y_train)
model_2.fit(X_train, y_train)
model_3.fit(X_train, y_train)

# Lakukan prediksi menggunakan masing-masing model pada data test (X_test)
y_pred = model.predict(X_test)
y_pred2 = model_2.predict(X_test)
y_pred3 = model_3.predict(X_test)

# Membuat DataFrame untuk membandingkan hasil prediksi model Logistic Regression dengan nilai sebenarnya
result = pd.DataFrame(list(zip(y_pred, y_test)), columns=['y_pred', 'y_test'])
result.head()

"""# Evaluation

**A. Confusion Matrix**
"""

# Import library yang diperlukan
from sklearn.metrics import confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Hitung confusion matrix untuk setiap model
# Model 1: Logistic Regression
cm = confusion_matrix(y_test, y_pred)

# Model 2: Random Forest
cm2 = confusion_matrix(y_test, y_pred2)

# Model 3: XGBoost
cm3 = confusion_matrix(y_test, y_pred3)

# Buat figure dengan 3 subplot dalam satu baris
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Plot confusion matrix untuk Model 1
sns.heatmap(cm, annot=True, fmt='.0f', cmap=plt.cm.Blues, ax=axes[0])
axes[0].set_title("Confusion Matrix - Model 1")
axes[0].set_xlabel("Predicted")
axes[0].set_ylabel("Actual")

# Plot confusion matrix untuk Model 2
sns.heatmap(cm2, annot=True, fmt='.0f', cmap=plt.cm.Blues, ax=axes[1])
axes[1].set_title("Confusion Matrix - Model 2")
axes[1].set_xlabel("Predicted")
axes[1].set_ylabel("Actual")

# Plot confusion matrix untuk Model 3
sns.heatmap(cm3, annot=True, fmt='.0f', cmap=plt.cm.Blues, ax=axes[2])
axes[2].set_title("Confusion Matrix - Model 3")
axes[2].set_xlabel("Predicted")
axes[2].set_ylabel("Actual")

plt.tight_layout()
plt.show()

"""

*   **Logistic Regression:**

  Model ini cenderung menghasilkan jumlah false negatives (FN) yang lebih tinggi, artinya sering gagal mendeteksi kasus dengan risiko kredit tinggi. Akibatnya, ada risiko bahwa peminjam dengan potensi gagal bayar tidak teridentifikasi secara tepat.
*   **Random Forest:**

  Dibandingkan dengan Logistic Regression, Random Forest berhasil meningkatkan jumlah true positives (TP) secara signifikan, sehingga lebih baik dalam mendeteksi kasus positif. Namun, model ini masih menghasilkan sedikit lebih banyak false positives (FP) jika dibandingkan dengan XGBoost, yang berarti ada kecenderungan untuk mengklasifikasikan beberapa kasus dengan risiko rendah sebagai berisiko.

* **XGBoost:**
  Secara keseluruhan, XGBoost memberikan performa terbaik. Model ini berhasil mengurangi jumlah false negatives dibanding Logistic Regression dan memiliki false positives yang lebih rendah dibanding Random Forest. Dengan demikian, XGBoost lebih andal dalam mengidentifikasi peminjam dengan risiko kredit tinggi, sehingga cocok untuk digunakan dalam pengambilan keputusan yang sensitif terhadap risiko.
"""

plt.hist(y_pred)

# Dapat dilihat bahwa model prediksi dari variabel dependent atau y_pred dapat dikatakan hampir seimbang / balance

"""**B.  Models Accuracy**"""

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, classification_report
import seaborn as sns
import matplotlib.pyplot as plt

# Menghitung metrik evaluasi untuk Model 1: Logistic Regression
metrics_model1 = {
    'Accuracy': accuracy_score(y_test, y_pred),
    'Precision': precision_score(y_test, y_pred),
    'Recall': recall_score(y_test, y_pred),
    'F1 Score': f1_score(y_test, y_pred),
    'ROC AUC': roc_auc_score(y_test, y_pred)
}

# Menghitung metrik evaluasi untuk Model 2: Random Forest
metrics_model2 = {
    'Accuracy': accuracy_score(y_test, y_pred2),
    'Precision': precision_score(y_test, y_pred2),
    'Recall': recall_score(y_test, y_pred2),
    'F1 Score': f1_score(y_test, y_pred2),
    'ROC AUC': roc_auc_score(y_test, y_pred2)
}

# Menghitung metrik evaluasi untuk Model 3: XGBoost
metrics_model3 = {
    'Accuracy': accuracy_score(y_test, y_pred3),
    'Precision': precision_score(y_test, y_pred3),
    'Recall': recall_score(y_test, y_pred3),
    'F1 Score': f1_score(y_test, y_pred3),
    'ROC AUC': roc_auc_score(y_test, y_pred3)
}


# Menampilkan hasil evaluasi untuk Model 1: Logistic Regression
print("Evaluation Metrics for Logistic Regression:")
for key, value in metrics_model1.items():
    print(f"{key}: {value:.4f}")
print("\n")

# Menampilkan hasil evaluasi untuk Model 2: Random Forest
print("Evaluation Metrics for Random Forest:")
for key, value in metrics_model2.items():
    print(f"{key}: {value:.4f}")
print("\n")

# Menampilkan hasil evaluasi untuk Model 3: XGBoost
print("Evaluation Metrics for XGBoost:")
for key, value in metrics_model3.items():
    print(f"{key}: {value:.4f}")
print("\n")

print("Classification Report for Logistic Regression:\n", classification_report(y_test, y_pred))
print("\n")
print("Classification Report for Random Forest:\n", classification_report(y_test, y_pred2))
print("\n")
print("Classification Report for XGBoost:\n", classification_report(y_test, y_pred3))

"""### Logistic Regression
- **Akurasi:** 0.8502  
  *Model ini memprediksi status pinjaman dengan benar sebanyak 85.02% dari total kasus.*

- **Presisi:** 0.9434  
  *Ketika model memprediksi pinjaman berisiko tinggi (kelas 1), akurasi prediksinya mencapai 94.34%.*

- **Recall:** 0.7450  
  *Model ini berhasil mendeteksi 74.50% dari total pinjaman berisiko tinggi, yang berarti ada sekitar 25.50% kasus yang tidak terdeteksi (false negatives).*

- **F1 Score:** 0.8326  
  *F1 Score menggabungkan presisi dan recall, sehingga memberikan gambaran performa keseluruhan yang sedang.*

- **ROC AUC:** 0.8502  
  *Nilai ROC AUC sebesar 85.02% menunjukkan bahwa model ini cukup baik dalam membedakan antara pinjaman yang baik dan berisiko tinggi.*

*Interpretasi:* Logistic Regression cenderung menghasilkan false negatives yang tinggi, sehingga kurang efektif dalam mendeteksi pinjaman berisiko tinggi meskipun presisinya tinggi.

---

### Random Forest
- **Akurasi:** 0.9540  
  *Model ini mencapai akurasi 95.40%, menunjukkan performa yang sangat baik secara keseluruhan.*

- **Presisi:** 0.9775  
  *Presisi 97.75% menunjukkan bahwa prediksi pinjaman berisiko tinggi oleh model ini sangat tepat.*

- **Recall:** 0.9293  
  *Recall sebesar 92.93% menandakan bahwa model berhasil mendeteksi sebagian besar pinjaman berisiko tinggi.*

- **F1 Score:** 0.9528  
  *F1 Score yang tinggi menandakan keseimbangan yang sangat baik antara presisi dan recall.*

- **ROC AUC:** 0.9540  
  *Nilai ROC AUC 95.40% mengindikasikan bahwa model ini sangat efektif dalam membedakan antara kedua kelas.*

*Interpretasi:* Random Forest meningkatkan jumlah true positives secara signifikan dibanding Logistic Regression, meskipun masih menghasilkan sedikit false positives bila dibandingkan dengan XGBoost.

### XGBoost
- **Akurasi:** 0.9431  
  *Akurasi 94.31% menunjukkan performa yang sangat baik secara keseluruhan.*

- **Presisi:** 0.9866  
  *Presisi 98.66% berarti hampir semua prediksi pinjaman berisiko tinggi oleh model ini benar.*

- **Recall:** 0.8984  
  *Recall 89.84% menunjukkan bahwa model ini berhasil mendeteksi sebagian besar pinjaman berisiko tinggi, dengan lebih sedikit kasus yang terlewat dibanding Logistic Regression.*

- **F1 Score:** 0.9404  
  *F1 Score yang tinggi mencerminkan keseimbangan yang sangat baik antara presisi dan recall.*

- **ROC AUC:** 0.9431  
  *Nilai ROC AUC 94.31% mengonfirmasi bahwa model ini efektif dalam membedakan antara kedua kelas.*

*Interpretasi:* XGBoost memberikan performa terbaik secara keseluruhan, dengan false negatives lebih sedikit dibanding Logistic Regression dan false positives lebih rendah dibanding Random Forest.
"""

from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# Menghitung probabilitas prediksi positif (kelas 1) menggunakan model (misalnya, Logistic Regression)
y_prob = model.predict_proba(X_test)[:, 1]  # Ambil probabilitas untuk kelas 1

# Menghitung nilai False Positive Rate (FPR) dan True Positive Rate (TPR)
fpr, tpr, _ = roc_curve(y_test, y_prob)

# Menghitung nilai AUC (Area Under Curve)
roc_auc = auc(fpr, tpr)

# Membuat plot kurva ROC
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='blue', lw=2, label=f'ROC Curve (AUC = {roc_auc:.4f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--', lw=1)  # Garis diagonal sebagai referensi
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate (FPR)', fontsize=12)
plt.ylabel('True Positive Rate (TPR)', fontsize=12)
plt.title('Receiver Operating Characteristic (ROC) Curve', fontsize=14)
plt.legend(loc='lower right')
plt.grid(True)
plt.show()

# Menghitung probabilitas prediksi positif (kelas 1) untuk model_2
y_prob = model_2.predict_proba(X_test)[:, 1]

# Menghitung nilai False Positive Rate (FPR), True Positive Rate (TPR), dan ambang batas
fpr, tpr, thresholds = roc_curve(y_test, y_prob)

# Menghitung nilai AUC (Area Under Curve)
roc_auc = auc(fpr, tpr)

# Membuat plot ROC Curve dengan tampilan yang diperbarui
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='blue', lw=2, label=f'ROC Curve (AUC = {roc_auc:.4f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--', lw=1, label='Random Classifier')
plt.xlabel('False Positive Rate (FPR)', fontsize=12)
plt.ylabel('True Positive Rate (TPR)', fontsize=12)
plt.title('Receiver Operating Characteristic (ROC) Curve for Model_2', fontsize=14)
plt.legend(loc='lower right', fontsize=10)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.grid(True)
plt.show()

# Menghitung probabilitas prediksi positif (kelas 1) untuk model_3
y_prob = model_3.predict_proba(X_test)[:, 1]  # Ambil probabilitas kelas 1

# Menghitung nilai False Positive Rate (FPR), True Positive Rate (TPR), dan ambang batas
fpr, tpr, thresholds = roc_curve(y_test, y_prob)

# Menghitung nilai AUC (Area Under Curve)
roc_auc = auc(fpr, tpr)

# Membuat plot ROC Curve untuk model_3
plt.figure(figsize=(8,6))
plt.plot(fpr, tpr, color='blue', lw=2, label=f'ROC Curve (AUC = {roc_auc:.4f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--', lw=1, label='Random Classifier')  # Garis diagonal sebagai referensi
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate (FPR)', fontsize=12)
plt.ylabel('True Positive Rate (TPR)', fontsize=12)
plt.title('Receiver Operating Characteristic (ROC) Curve for Model_3', fontsize=14)
plt.legend(loc='lower right', fontsize=10)
plt.grid(True)
plt.show()

"""#Conclusion

Berdasarkan Exploratory Data Analysis (EDA), ditemukan bahwa jumlah pinjaman meningkat tajam pada tahun 2014, dengan sebagian besar pinjaman mengalami keterlambatan 10-30 bulan. Hasil uji ANOVA menunjukkan bahwa usia kredit berpengaruh terhadap status pinjaman yang buruk, dengan peminjam yang lebih muda cenderung berisiko lebih tinggi.

Dari segi pemodelan, XGBoost menunjukkan kinerja terbaik dalam hal akurasi dan evaluasi metrik seperti False Positives dan False Negatives. Untuk meminimalkan kesalahan dalam mendeteksi peminjam berisiko tinggi, XGBoost atau Random Forest lebih direkomendasikan daripada Logistic Regression, sementara XGBoost lebih disarankan jika ingin mengurangi False Positives secara ketat.
"""